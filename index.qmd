---
logo: "img/wtf-logo-square-transparent.png"
format: 
  revealjs: 
    theme: [night, slides.scss]
    highlight-style: a11y
    transition: fade
    slide-number: true
    chalkboard: true
    navigation-mode: linear
    controls: false
    mermaid-format: svg
execute:
  freeze: auto
from: markdown+emoji
---

# Using Version Control {background-image="img/forks.jpg"}

## imagine we need to work on a paper together

how could you do that?

::: fragment
::: {layout-nrow=1}
![dropbox](img/dropbox.svg){width=20%}
![shared drive](img/fileserver.svg){width=20%}
![email](img/email.png){width=20%}
![google docs](img/googledocs.svg){width=20%}
:::
:::

::: notes
let's talk about how we're not solving the problem:

If you and I need to collaborate on a document _today_, what options do we have?
what version of the document is the authoritative one?
if you and I change the same thing:
how do we discover that we did this?
how do we know whose edits win?

warm up discussion: consider these mechanisms for shared editing

- dropbox
- email attachments
- shared drive
- a google doc
- sharepoint

Limitations:
You have to trust dropbox to figure out conflicts for you and then hope they got it right
every email attachment of the document is a new, potentially authortiative copy and this gets increasingly confusing as you add collaborators
we may not have access to the same proprietary program for editing
shared drive: typically only one person can modify the program at a time, depends on shared disk access
google docs are pretty good, actually, until we start talking about code

what if you're working on code? what if your collaborators are strangers? what if they're halfway around the world?

plain text is a least common denominator
we're not assuming access to shared hardware
we are assuming that collaboration is async
:::

## on plain text

![beware](img/evernote.png)

## agenda

- terminology
- workflows: I
- tools
- workflows: II
- unhappy paths

# terminology

## git

_distributed_ version control system

::: notes
distributed = we all have a copy
contrast with other approaches where there is only one copy an
:::

## repository

```shell
./
├── ChangeLog
├── config.site
├── configure*
├── configure.ac
├── configure.patch
├── COPYING
├── doc/
├── etc/
├── INSTALL
├── m4/
├── Makeconf.in
├── Makefile.fw
├── Makefile.in
├── po/
├── README
├── share/
├── src/
├── tests/
├── tools/
├── VERSION
└── VERSION-NICK
```

::: notes
a repository is a a project
opinions on the scope of what belongs in a single repository vary widely
monorepos?
:::

## remote

git vs. github / gitlab / bitbucket

## commit

```{mermaid}
gitGraph
  commit id: "initial commit"
  commit id: "snapshot one"
  commit id: "snapshot two"
```

## diff

## stage

`git add`

# workflows: I

solo

## `git status`

```shell
❯ git status
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   index.qmd

```

## start locally

```bash
git init
git add .
git commit
```

## `EDITOR`

vim, nano

## publish to github

[existing project, github first](https://happygitwithr.com/existing-github-first.html)

## push, pull

# tools

## `{prompt}`

https://github.com/gaborcsardi/prompt

## starship

https://starship.rs/

##  gh

https://cli.github.com/

## vs code

https://code.visualstudio.com/

# workflows: II

## gitignore

## clean

generated files chat

## branch

```{mermaid}
gitGraph
  commit
  commit
  commit
  branch experiment
  checkout experiment
  commit
```

## merge


```{mermaid}
gitGraph
  commit
  commit
  commit
  branch experiment
  checkout experiment
  commit
  checkout main
  merge experiment
```

## PRs

# unhappy paths

## merge conflicts

```{mermaid}
gitGraph
  commit
  commit
  commit
  branch experiment
  checkout experiment
  commit
  checkout main
  commit
```
