---
logo: "img/wtf-logo-square-transparent.png"
format: 
  revealjs: 
    theme: [night, slides.scss]
    highlight-style: a11y
    transition: fade
    slide-number: true
    chalkboard: true
    navigation-mode: linear
    controls: false
    mermaid-format: svg
execute:
  freeze: auto
from: markdown+emoji
---

# Using Version Control {background-image="img/forks.jpg"}

## imagine we need to work on a paper together 

how should we do that?  

## key questions

- which version of the document is the authoritative one?  
- if you and I change the same thing:
  - how will we know we did that?
  - whose edits should win?

## some solutions

::: fragment
::: {layout-nrow=1}
![dropbox](img/dropbox.svg){width=20%}
![shared drive](img/fileserver.svg){width=20%}
![email](img/email.png){width=20%}
![google docs](img/googledocs.svg){width=20%}
:::
:::

::: notes
let's talk about how we're not solving the problem:

If you and I need to collaborate on a document _today_, what options do we have?

warm up discussion: consider these mechanisms for shared editing and limitations:

- dropbox
  - You have to trust dropbox to figure out conflicts for you and then hope they got it right
- email attachments
  - every email attachment of the document is a new, potentially authortiative copy and this gets increasingly confusing as you add collaborators
  - `doc_date_FINAL.docx`
- shared drive
  - typically only one person can modify the document at a time
- sharepoint
  - we may not have access to the same proprietary program for editing
  - depends on shared service access
- a google doc
  - google docs are pretty good, actually, until we start talking about code


what if you're working on code? what if your collaborators are strangers? what if they're halfway around the world?

plain text is a least common denominator
we're not assuming access to shared hardware
we are assuming that collaboration is async
:::

## on plain text

![beware](img/evernote.png)

::: notes
Be careful about storing valuable IP of yours in places that can take it away from you when they change business models
:::


## agenda

- terminology
- workflows: I
- tools
- workflows: II
- unhappy paths

# terminology

## git

_distributed_ version control system

::: notes
distributed = we all have a copy
contrast with other approaches where there is only one copy
:::

## repository

```shell
./
├── ChangeLog
├── config.site
├── configure*
├── configure.ac
├── configure.patch
├── COPYING
├── doc/
├── etc/
├── INSTALL
├── m4/
├── Makeconf.in
├── Makefile.fw
├── Makefile.in
├── po/
├── README
├── share/
├── src/
├── tests/
├── tools/
├── VERSION
└── VERSION-NICK
```

::: notes
a repository is a a project
opinions on the scope of what belongs in a single repository vary widely
monorepos?
:::

## remote

git vs. github / gitlab / bitbucket

::: notes
git is decentralized
github is how we coordinate
the authoritative copy is stored by the code host
:::

## commit

```{mermaid}
gitGraph
  commit id: "initial commit"
  commit id: "snapshot one"
  commit id: "snapshot two"
```

::: notes
a snapshot of project state
:::

## diff

::: notes
the difference between  _any_ two project snapshots
:::

## stage

`git stage`

::: notes
all the documentation you will ever see is for `git add`
:::

# workflows: I


## new project

- create project (from rstudio, or terminal)

```bash
mkdir intro-git
cd intro-git
git init
```

## `git status`

```shell
❯ git status
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   index.qmd

```

## `git stage`

```bash
❯ git status
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   index.qmd
```

## `git commit`


```bash

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch main
# Your branch is up to date with 'origin/main'.
#
# Changes to be committed:
#       modified:   index.qmd
#
"~/Documents/projects/wtf-version-control-slides/.git/COMMIT_EDITMSG" 13L, 317B
```

## `EDITOR`

::: notes
### vim
normal mode
insert mode, write a message
`ESC` to return to normal mode
`:` to enter command mode
`wq` to write the file and quit

### nano

start typing
`CTRL + O` to save
`CTRL + X` to exit
:::

## repeat

with rstudio, vscode

## publish to github

[existing project, github first](https://happygitwithr.com/existing-github-first.html)

## push

# tools

## `{prompt}`

https://github.com/gaborcsardi/prompt

## starship

https://starship.rs/

##  gh

https://cli.github.com/

## vs code

https://code.visualstudio.com/

# workflows: II

## gitignore

## clean

generated files chat

## branch

```{mermaid}
gitGraph
  commit
  commit
  commit
  branch experiment
  checkout experiment
  commit
```

## merge


```{mermaid}
gitGraph
  commit
  commit
  commit
  branch experiment
  checkout experiment
  commit
  checkout main
  merge experiment
```

## PRs

# unhappy paths

## merge conflicts

```{mermaid}
gitGraph
  commit
  commit
  commit
  branch experiment
  checkout experiment
  commit
  checkout main
  commit
```
